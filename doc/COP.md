# COP欠陥パターンの分類体系

## 概要

COPの欠陥パターンを体系的に整理し、本研究のアサーションがどこをカバーしているか議論する。

## 目的

1. **欠陥の体系化**: COP機構による欠陥にはどのようなものがあるか
2. **カバレッジの確認**: 私たちのツールがカバーしている欠陥はどのようなものか
3. **ギャップの特定**: 逆にどのような欠陥をカバーしていないか
4. **改善の検討**: それに基づく仕様の見直しや、追加実装の検討

## 参考文献

- **[1] Context-Oriented Programming (Hirschfeld, Costanza, Nierstrasz, 2008)** - COP原論文
- [2] A framework for analyzing context-oriented programming languages (2023)
- [3] A Comparison of Context-oriented Programming Languages (Appeltauer et al., 2009)
- [4] Context-Oriented Behavioral Programming (2020)
- [5] Test scenario generation for feature-based COP (2022)

---

## 論文[1]からの知見: COPの基礎概念

### COPの5つの構成要素

論文が定義するCOPの必須要素。**欠陥が潜む可能性のある場所**として分類軸に使える。

| 構成要素 | 説明 | 欠陥の可能性（仮説） |
|---------|------|-------------------|
| **Behavioral variations** | 振る舞いの変化（追加/変更/削除）、`proceed`による元メソッド呼び出し | proceed呼び忘れ、無限ループ |
| **Layers** | 変化のグループ化、第一級エンティティ | 複数層の競合、順序依存 |
| **Activation** | 動的な活性化/非活性化 | 活性化状態の不整合、予期しない遷移 |
| **Context** | 計算的にアクセス可能な任意の情報 | 条件検査の誤り |
| **Scoping** | 活性化範囲の明示的制御 | スコープの誤り、意図しない範囲への影響 |

### コンテキストの3分類

層の活性化を**誰が制御するか**による分類。**欠陥の発生源**の観点として使える。

| 分類 | 層を制御する主体 | 例 | 欠陥の可能性（仮説） |
|-----|----------------|---|-------------------|
| **Actor-dependent** | 外部クライアント | ビューの選択（住所表示/非表示） | 間違った層の指定 |
| **Environment-dependent** | 環境条件 | バッテリー残量、ログイン状態 | 条件検査漏れ、競合条件 |
| **System-dependent** | システム内部 | 画面更新の最適化（自己非活性化） | **予期しない内部状態遷移** |

### 多次元ディスパッチ

COPは4次元ディスパッチ（メソッド名 + レシーバー + センダー + コンテキスト）を実現。

- 複雑性が増す
- どのメソッドが実際に呼ばれるか予測が難しくなる可能性

### AOPとの違い

> "COP allows the use of layer activation/deactivation in **arbitrary places** of the source code whereas pointcuts in AOP can only trigger at join points as exposed by the rest of the program."

- COPは任意の場所で活性化可能 → 柔軟だが、誤用のリスクも？

---

## 論文[2]からの知見: COPLの分析フレームワーク

### 論文の問題意識

COPLの比較・評価が困難な理由：

- 動的適応の**実現方法**が異なる
- **用語**が異なる
- **プログラミングインターフェース**が異なる
- **標準的な評価基準がない**

→ 既存の分析は10年以上前、技術的側面のみ、層ベースに偏重

### フレームワークの4つの評価軸

| 軸 | 内容 |
|---|------|
| Criterion 1: Goal | 言語の目的 |
| Criterion 2: Concepts | BContext、関係性、ライフサイクル、振る舞い変化 |
| Criterion 3: Process Support | 方法論、**推論**、**テスト** |
| Criterion 4: Pragmatics | 実用面（使用状況、リソース、保守性など） |

### 欠陥に直結する記述

#### Behavioral Consistency（振る舞いの一貫性）問題

> "The interactions between the system behavior and the system context may produce **unexpected behavior** that is hard to foresee. This may result in **inconsistencies in the application logic**."

例: Night BContext と Emergency BContext の矛盾

#### テストの課題

> "The COP paradigm introduces **challenges in testing** such programs. This is due to **multiple BContexts and behavioral variations** that may affect the system's behavior."

3言語（ServalCJ, Subjective-C, COBPjs）の比較で、Testing は ServalCJ と Subjective-C が **None**。

### BContext間の関係タイプ

| 関係タイプ | 説明 | 欠陥の可能性 |
|-----------|------|-------------|
| Structural | 関連、継承 | 継承時の振る舞い不整合 |
| Dependency | 依存関係 | 依存先の未活性化 |
| Temporal | 時間的順序 | 順序違反 |
| **Priority** | 優先度 | **矛盾する振る舞いの同時活性化** |
| Constraints | 制約 | 制約違反 |

### 非活性化時のライフサイクル

| タイプ | 説明 |
|-------|------|
| Prompt | 即座に中断 |
| Prompt + Cleanup | 中断 + クリーンアップタスク実行 |
| Loyal | 現在の実行完了まで待機 |

> "clean-up tasks can be executed to **avoid reaching inconsistent or erroneous systems states** due to the interruption"

### 参考文献（深掘り候補）

- Cardozo et al., 2015: "Semantics for **consistent activation** in context-oriented systems"
- Cardozo et al., 2012b: "Context Petri nets: Enabling **consistent composition**"
- Salvaneschi et al., 2012a: "Context-oriented programming: **A software engineering perspective**"

---

## 考慮すべき事項（議論中）

### 共通の欠陥 vs 言語特有の欠陥

COPLは実現方法・用語・インターフェースが異なるため、欠陥を議論する際に区別が必要：

| 分類 | 説明 |
|------|------|
| **COP共通の欠陥** | どのCOPL実装でも発生しうる、パラダイム固有の問題 |
| **言語特有の欠陥** | 特定の言語実装に起因する問題 |

**EMA.jsはあくまで一つの言語実装**。より引いた視点でCOP全体としてどういった対応が必要かも議論すべき。

### 今後の議論で考慮すべき点

1. 共通の欠陥パターンを抽出し、言語非依存で定義できるか
2. 私たちのアサーションは共通の欠陥を検出しているか、EMA.js固有か
3. 他のCOPLで同等のアサーションを実装するには何が必要か

### 考察ポイント（後で議論）

#### A. Goal（目的）から得られる洞察

**1. Goal = 既存の欠陥への対策**

新しい手法は既存の問題を解決するために提案される。

```
既存の欠陥（if文の乱立、関心の混在）
    ↓ 解決したい
COPの提案
    ↓ 
Goal として明文化
```

Goal を見れば「**何を防ごうとしているか**」がわかる。

**2. Goal = 正しいCOPコードの指針**

| Goal | 正しい使い方 | 誤った使い方 |
|------|-------------|-------------|
| 関心の分離 | 層ごとに独立した振る舞い | 層間で密結合 |
| 要件の分類 | コンテキストで要件をグループ化 | 無関係な要件を同じ層に |
| 第一級市民 | コンテキストを明示的に操作 | 暗黙的な状態変更 |

Goal に沿った使い方 = **ケーススタディの材料**になる。

**3. テストツールの役割についての問い**

| 選択肢 | 説明 |
|--------|------|
| **A. サポートしない** | COPの思想に反する使い方は、テストツールの対象外とする |
| **B. 誘導する** | テストツールの構文・利用方法で、正しい使い方に導く |

- COPの思想や目的に反する使い方をしている場合、テストツールでサポートするのは不適切？
- もしくは、テストツールの構文や利用方法を設計することで、COPの目的や思想に誘導すべき？

**4. コンテキスト単位でのテスト（アイデア未定）**

コンテキストが第一級市民で、コンテキストごとにモジュール化しているなら、**その単位でテストしたい**かもしれない。

```javascript
// コンテキスト単位でのテスト？
describeContext(Night, () => {
    // Night コンテキストに関連するすべての振る舞いをテスト
});

describeContext(Emergency, () => {
    // Emergency コンテキストに関連するすべての振る舞いをテスト
});
```

→ 具体的なアイデアはまだないが、検討の余地あり。

---

**5. 宣言的 vs 命令的な活性化（重要な論点）**

BContext の活性化方式には2種類ある：

| 方式 | precondition | 活性化の主体 | 例 |
|------|-------------|-------------|---|
| **宣言的** | データを参照する | システム（自動） | `precondition: time >= 21` |
| **命令的** | データを参照しない | プログラマ（手動） | `activate(Night)` |

**論文[1]の分類との対応**：
- 宣言的 → Environment-dependent, System-dependent
- 命令的 → Actor-dependent

**命令的のメリット**：
- 制御の明確さ（いつ活性化したかわかる）
- タイミングの制御（条件を満たしても、まだ活性化しない選択ができる）
- 複雑な条件・順序の制御
- デバッグのしやすさ（スタックトレースで追跡可能）

**私たちのツールのサポート状況**：

| 観点 | 命令的 | 宣言的 |
|------|--------|--------|
| **結果のチェック** | ✅ サポート | ✅ サポート |
| **特有の欠陥検出** | ✅ 活性化忘れ等 | ❌ タイミング、競合 |

**後で議論すべきこと**：
- 命令的な活性化で起こりうる**具体的な欠陥パターン**は何か
- 現在の表明機構で**カバーできている欠陥**は何か
- **カバーできていない欠陥**は何か
- 宣言的特有の欠陥（競合状態、評価タイミング）をどうサポートするか

---

**6. 振る舞い依存の活性化（Criterion 2.1 観点3）**

BContext の前提条件が**他の振る舞いの実行状態**を参照するかどうか。

| パターン | 説明 | 例 |
|---------|------|---|
| **振る舞いを参照する** | 他の振る舞いの完了を条件にする | `precondition: login.isCompleted()` |
| **振る舞いを参照しない** | データや明示的呼び出しのみ | `precondition: time >= 21` |

**振る舞い依存で起こりうる欠陥**：
- 完了検知ミス（振る舞いが本当に完了したか誤判定）
- デッドロック（互いの完了を待ち合う）
- 順序依存（振る舞いの実行順序に依存した不具合）

**私たちのツールのサポート状況**：

| 前提条件の参照先 | サポート状況 |
|-----------------|-------------|
| データを参照しない（命令的） | ✅ 対象 |
| データを参照する（宣言的） | △ 結果のみ確認可能 |
| **振る舞いを参照する** | ❌ 対象外 |

**備考**：
- COBPjs（Behavioral Programming + COP）がこの仕組みをサポートしている可能性
- EMA.js にはこの機能がないため、私たちのツールもこの欠陥を検出していない
- 詳細は論文 Section 5 で確認が必要

---

**7. Criterion 2.1（BContext）の5つの観点まとめ**

| 観点 | 内容 | 私たちのツールとの関連 |
|------|------|----------------------|
| 1. データカプセル化 | BContextが独自のデータを持つか | EMA.jsは持たない |
| 2. データを前提条件として参照 | 活性化条件がデータを見るか（宣言的 vs 命令的） | 命令的を主にサポート |
| 3. 振る舞いを前提条件として参照 | 他の振る舞いの完了を条件にするか | ❌ 対象外 |
| 4. 複数振る舞いで使えるか | 1つのBContextに複数の振る舞いを紐づけられるか | 前提として採用（1対1は稀） |
| 5. 静的・動的 | BContextの条件が不変か変化するか | 動的が主な対象 |

**静的 vs 動的 BContext と欠陥の関連**：

| タイプ | 説明 | 例 | 欠陥の可能性 |
|--------|------|---|-------------|
| **静的** | 不変の属性に基づく | Kitchen、Admin、Mobile | 少ない（変化しないので予測しやすい） |
| **動的** | 変化する状態に基づく | Night、LowBattery、Offline | 多い（状態変化のタイミング、競合など） |

私たちのツールは主に**動的な状態変化**を検証している。静的なBContextは変化しないため、テストの必要性が低い。

**動的BContext特有の欠陥（後で詳細議論）**：

| 欠陥 | 説明 |
|------|------|
| 状態変化のタイミング | いつ活性化/非活性化されるか |
| 競合状態 | 複数のBContextが同時に変化 |
| 境界条件 | `time >= 21` のちょうど21:00の扱い |
| 遷移中の不整合 | 活性化途中の状態 |

**議論すべきこと**：
- 言語によって状態変化のメカニズムが異なる
- そのメカニズムの違いによって、どのような欠陥が生じうるか
- 私たちのツールは現在、タイミングや競合状態を直接検出する仕組みがない

**8. テストツールの目的（重要な整理）**

COPのテストは以下に分けられる：

1. **活性化が意図通りにいくか** - COP機構の動作検証
2. **COPで定義されているコードが正しいか** - ビジネスロジックの検証

私たちのツールは主に**1**を対象としている。

**テストの本質**：

```
COPの構文を正しく使う
        ↓
意図した動作になるか検証
        ↓
ならない → 欠陥
```

**COPにおける「意図した動作」**：

| 観点 | 意図の例 |
|------|---------|
| 層の活性化 | この層が有効になっているはず |
| 振る舞いの選択 | このメソッドが呼ばれるはず |
| 状態遷移 | この順序で遷移するはず |
| スコープ | この範囲だけに影響するはず |

**論文で分析したいこと**：
- 「意図した動作」が具体的にどういうものか
- それがうまくいかない場合、どういった欠陥を生むか
- 言語が提供する構文・機構に対して、プログラマが意図できる範囲でサポートする

**注意**：
- 言語が構文として提供していない機構をテストしても意味がない
- プログラマがCOPの思想に沿って書くとき、どういう欠陥が既存パラダイムとは違う形で生じるかを明確にする

**9. Deactivation（非活性化）の複雑さ（後で詳細議論）**

非活性化には3つのタイプがある（Criterion 2.5）：

| タイプ | 説明 | 実行中の振る舞いへの影響 |
|-------|------|------------------------|
| **Prompt** | 即座に中断 | 実行中でも即座にコンテキスト変更を適用 |
| **Prompt + Cleanup** | 中断 + クリーンアップ | 中断するが、不整合を避けるためクリーンアップタスクを実行 |
| **Loyal** | 完了まで待機 | 現在の実行が完了するまで待ち、その後コンテキスト変更 |

**言語ごとの違い**：

| 言語 | Deactivation |
|------|-------------|
| ServalCJ | Prompt or Prompt-loyal（モデルによる） |
| Subjective-C | Prompt-loyal |
| COBPjs | 3タイプすべてサポート |

**タイプごとの欠陥の可能性**：

| タイプ | 欠陥の可能性 |
|-------|-------------|
| **Prompt** | 実行途中で中断 → 不整合な状態 |
| **Prompt + Cleanup** | クリーンアップの実装漏れ → リソースリーク |
| **Loyal** | 完了を待つ → デッドロック、タイムアウト |

**議論すべきこと**：
- 言語ごとに仕様が異なる
- 仕様ごとにどういった欠陥が生じるか
- EMA.js の `withLayer()` は Prompt に近い動作だが、クリーンアップや Loyal の概念はない

**10. Criterion 2.4 観点3: インスタンス分離 vs グローバル**

BContextが複数インスタンスを持つ場合の振る舞い実行パターン：

| パターン | 説明 | 例 |
|---------|------|---|
| **インスタンス分離** | 各インスタンスごとに独立して実行 | COBPjs |
| **グローバル** | システム全体に影響 | EMA.js |

**テストの関心の違い**：

| パターン | テストの関心 |
|---------|-------------|
| **インスタンス分離** | 意図した対象に影響しているか（正しいインスタンスか） |
| **グローバル** | 意図しない対象に影響を与えていないか |

**私たちのツールとの関連**（EMA.jsはグローバル）：

- 「意図しない影響がないか」を検証する必要がある
- `toBePartialMethodOf()` で部分的にサポート
- より明示的なサポートの検討余地あり

**11. Criterion 2.4 観点4: スコーピングと欠陥**

スコープの種類（言語による）：

| スコープ | 説明 | 例 |
|---------|------|---|
| グローバル | システム全体に影響 | EMA.js `Night.enable()` |
| ブロック | 特定のコードブロック内 | EMA.js `withLayer()` |
| オブジェクトごと | 特定のオブジェクトのみ | ServalCJ |
| スレッドローカル | 特定のスレッドのみ | Subjective-C |
| インスタンス | BContextインスタンスのみ | COBPjs |

**スコープごとの欠陥パターン**：

| スコープ | 欠陥の可能性 |
|---------|-------------|
| **グローバル** | 影響が広すぎる、意図しないオブジェクトに影響 |
| **オブジェクトごと** | 指定漏れ、指定ミス |
| **スレッドローカル** | スレッド間の不整合 |
| **ブロック** | ブロック外への漏れ |
| **インスタンス** | インスタンスの取り違え |

**共通するパターン**：

| パターン | 説明 |
|---------|------|
| **広すぎる** | 意図しない範囲に影響 |
| **狭すぎる** | 必要な範囲に影響していない |
| **タイミング** | スコープの開始/終了時の不整合（Deactivationの問題と関連）|

**私たちのツールへの示唆**：
- EMA.js はグローバル/ブロックスコープのみ
- 「意図しない影響がないか」の検証は難しい（すべてのオブジェクトをチェックは非現実的）
- スコープの境界（開始/終了）の検証が重要

**12. Criterion 2.4 観点6: 実行順序（重要）**

複数の振る舞い変化が同時に活性化されているとき、どの順序で実行されるか。

**実行順序の決定方法**：

| 方法 | 説明 |
|------|------|
| **ランダム** | 順序保証なし |
| **明示的指定** | プログラマが優先度を指定 |
| **活性化順** | 後から活性化された層が優先 |
| **定義順** | コードで先に定義された方が優先 |
| **動的決定** | 実行時に決まる |

**言語ごとの違い**：

| 言語 | 実行順序の決定 |
|------|---------------|
| ServalCJ | 最後に活性化された層が優先（LayerStack） |
| Subjective-C | 最後に活性化された層が優先 |
| COBPjs | 順序を指定しない場合、任意の順序 |
| EMA.js | 活性化順（後から活性化した層が優先） |

**方法ごとの欠陥**：

| 方法 | 欠陥の可能性 |
|------|-------------|
| **ランダム** | 予測不能な動作、テスト困難 |
| **活性化順** | 活性化の順序ミスで意図しない振る舞い |
| **明示的指定** | 優先度の設定ミス、矛盾する優先度 |
| **動的決定** | 実行時の条件で変わる、デバッグ困難 |

**私たちのツールとの関連**：

| 検証したいこと | 現在のサポート |
|---------------|---------------|
| どの層の振る舞いが実行されるか | `toBePartialMethodOf()` |
| 競合する層が同時に活性化されていないか | `assertNoConflictingMethodCalled()` |

**考慮事項**：
- COP特有の重要な欠陥に直結する
- 実行順序に応じた検証が必要
- EMA.js は活性化順なので、「どの順序で活性化したか」が重要

**13. Criterion 2.4 観点2,3: 後で議論が必要な観点**

**観点2: 複数BContextへのバインド**

| パターン | 説明 |
|---------|------|
| 可能 | 1つの振る舞いを複数のBContextで共有 |
| 不可 | BContextごとに別々に定義（EMA.js） |

欠陥の可能性：
- 可能な場合: 一方のBContextでの変更が他方に影響
- 不可の場合: コードの重複、同期漏れ（片方だけ修正）

→ 具体的な問題はわからないが、議論の余地あり

**観点3: 各インスタンスで実行**

| パターン | 説明 |
|---------|------|
| インスタンス分離 | 各BContextインスタンスで独立して実行（COBPjs） |
| グローバル | システム全体（EMA.js） |

テストの関心の違い：
- インスタンス分離: 意図した対象に影響しているか
- グローバル: 意図しない対象に影響していないか

→ EMA.jsは対象外だが、インスタンス分離を持つ言語では欠陥パターンの議論が必要

**14. ServalCJ の言語機能（議論の価値あり）**

ServalCJは言語レベルで以下の機能をサポート：

**物理的 vs 論理的コンテキスト**：
- 物理的: 環境変数（センサー値など）から直接判定
- 論理的: 他のBContextの組み合わせで定義

**言語レベルの制約記述**：
```java
// 排他制約
Hot :: RoomWithTaps && !Cold
Cold :: RoomWithTaps && !Hot

// 組み合わせ活性化
RoomWithTaps :: Kitchen || Bathroom
```

**contextgroup（コンテキストグループ）**：
```java
contextgroup SmartHome(Location loc, Geocode gcd) {
    activate Kitchen if(...);
    activate Cold when RoomWithTaps && !Hot;
}
```

役割：
- 関連するBContextをグルーピング
- 環境変数（Location, Geocode）を共有
- スコープ（global/perthis）を一括指定
- 保守性の向上

**EMA.jsとの比較**：
| 機能 | ServalCJ | EMA.js |
|------|----------|--------|
| 排他制約 | 言語で宣言 | 手動管理 |
| 組み合わせ活性化 | 言語で宣言 | 手動管理 |
| コンテキストグループ | あり | なし |

→ EMA.jsは言語レベルのサポートがないため、テストツールでこれらの検証をサポートする価値がある

**15. 透過的（transparently）な管理**

ServalCJの目標（Page 6）：
> "all situations that require dynamic adaption to the context are expressed in a natural way (i.e., clearly modularized) and managed uniformly and transparently by the developer."

**透過的の意味**：
- 内部の複雑さが隠蔽されている
- 開発者が詳細を意識しなくてよい
- システムが裏で自動的に処理してくれる

**透過的 vs 非透過的**：

| 観点 | 透過的（ServalCJ） | 非透過的（EMA.js） |
|------|-------------------|-------------------|
| 活性化 | 条件を宣言→自動 | 手動で `enable()` |
| 非活性化 | 条件が偽→自動 | 手動で `disable()` |
| 競合解決 | 言語が自動管理 | プログラマの責任 |
| スコープ | 宣言的に指定 | 手動で管理 |
| 開発者の負担 | 低い | 高い |
| バグの可能性 | 低い | 高い |

**私たちのツールの目標**：
- EMA.jsは非透過的だが、テストツールで**透過的に近い体験**を提供したい
- 手動管理のミスを自動検出
- 開発者が「意識しなくてよい」状態に近づける

**16. 非同期処理と prompt-loyal の欠陥**

**prompt-loyal とは**（Criterion 2.5）：
- 層の状態は即座に非活性化（prompt）
- 実行中のメソッドは完了まで実行（loyal）
- 新しい呼び出しは通常の振る舞い（prompt）

**同期コードの場合**：
JavaScript はシングルスレッドなので、実行中のメソッドは完了するまで割り込まれない。
→ 自然と prompt-loyal になる

**非同期コードの場合（欠陥の可能性）**：
```javascript
async function nightRoutine() {
    await door.close();  // Night の振る舞い
    // ← ここで Signal が変わり Night が非活性化される可能性
    await door.lock();   // Night? 通常? → 不整合
}
```

await の間に Signal が変化すると、層の状態が途中で変わる可能性がある。
→ **prompt-loyal が保証されない**
→ **非同期処理中の層の状態変化は欠陥になりうる**

**17. 欠陥の分類（後で詳細議論）**

| 分類 | 説明 | 例 |
|------|------|---|
| **COP共通の欠陥** | COPの概念に共通して検証したい | 排他制約違反、競合、依存関係の不整合 |
| **言語機構による欠陥** | 言語の設計・機構に起因 | スコーピングの違い、活性化方式の違い |
| **実装先による欠陥** | 実装先の環境に起因 | JavaScript の非同期処理、シングルスレッド |

この分類は後で欠陥パターンを整理する際に使用する。

**18. 活性化の2つのパターン（重要）**

| パターン | 説明 | 例 |
|---------|------|---|
| **暗黙的活性化** | 条件を宣言 → 言語が自動で活性化 | ServalCJ, EMA.js（Signal） |
| **明示的活性化** | プログラマが activate を呼ぶ | Subjective-C, EMA.js（enable/disable） |

**比較**：

| 観点 | 暗黙的 | 明示的 |
|------|--------|--------|
| 条件を書く | ✅ | ✅ |
| activate を呼ぶ | ❌（言語が自動） | ✅（自分で呼ぶ） |
| 責任 | 言語/ランタイム | プログラマ |
| 欠陥の可能性 | 低い | 高い |

**明示的活性化の欠陥パターン**：
- `activate` の呼び忘れ
- `deactivate` の呼び忘れ
- 条件と活性化の不整合
- 複数箇所での活性化による矛盾
- 定義と条件の分散（どこで活性化されるか追跡困難）

**テストツールへの示唆**：
- 明示的活性化を使う言語（Subjective-C, EMA.js）では、テストの価値が高い
- 暗黙的活性化でも、条件の誤りはテストで検出する必要がある

**19. アドホック開発と意図しない相互作用（重要）**

論文の指摘（Subjective-C, Page 11）：
> "The process of developing COP systems with Subjective-C is ad hoc."
> "the interaction between contexts is far from straightforward and unintended interactions may lead to erroneous behavior."

**アドホック開発の責任**：
開発者が定義する責任を負うもの：
1. コンテキスト（BContext）
2. 関連する振る舞い変化
3. コンテキストが発生すべき条件

**アドホックだからこそテストが必要**：
- 正式な方法論がない → 開発者のミスが起きやすい
- コンテキスト間の相互作用が複雑 → 意図しない相互作用が起きる
- テストで「責任を正しく果たせているか」を検証する価値がある

**意図しない相互作用の例**：
- Night と Emergency が両方活性化 → 矛盾する振る舞い
- Hot と Cold が同時に活性化 → 排他制約違反
- BContext A が BContext B を暗黙的に影響 → 予期しない振る舞い

**テストツールで検出すべきこと**：
- 排他制約の違反
- 依存関係の不整合
- 意図しない層の組み合わせ
- 活性化条件の誤り

**20. 論文の重要な指摘：COPLのテストの欠如（Section 7, Page 15）**

論文の原文：
> "COPLs fail to provide sufficient means to test the behavioral code that depends on different combinations of BContexts. This is particularly true for the different analyses related to coverage (i.e., testing every possible combination of active BContexts while testing) but also relates to the validation of the emergent behavior that can be observed once behavioral variations from several BContexts are applied to the system."

**2つの問題**：

| 問題 | 説明 |
|------|------|
| **カバレッジ** | アクティブなBContextのすべての可能な組み合わせをテストできない |
| **創発的な振る舞い** | 複数のBContextからの振る舞い変化が重なったときの振る舞いを検証できない |

**創発的な振る舞い（emergent behavior）とは**：
- 個々の層の振る舞いは正しい
- しかし複数の層が同時に活性化されたとき、予期しない振る舞いが生じる
- 個々のテストでは見つからない、組み合わせによる問題

**具体例**：
```
Night: door.close() → ドアをロック
Emergency: door.close() → ドアを開放

Night + Emergency が同時に活性化
    → どちらの振る舞いが適用される？
    → 予期しない状態になる可能性
```

**論文が認める欠点**：
> "Two notable drawbacks are the testing of COP systems"
（2つの注目すべき欠点の1つは、COPシステムのテストである）

**私たちのツールの価値**：
- BContext の組み合わせカバレッジを提供
- 創発的な振る舞いのテストを可能にする
- 論文が指摘する欠点を直接解決する

---

#### B. 論文[2]のフレームワークから得られた洞察

**1. 言語ごとの設計思想の違いが欠陥の定義を変える**

- フレームワークは言語間の**違いと設計思想を分類**するためのもの
- 同じ「欠陥」でも、ある言語では問題になり、別の言語では問題にならない可能性
- 例: 実行順序が「明示的指定」の言語 vs 「ランダム」の言語では、順序に関する欠陥の深刻度が異なる

**2. 議論すべき問い**

| 問い | 内容 |
|------|------|
| **検出可能性** | 言語特有の欠陥に対して、どのように検出できるか？ |
| **カバレッジ** | 他にどのような欠陥があり、現在カバーしていないか？ |
| **一般化** | 私たちのアサーションは他のCOPLでも使えるか？ |
| **言語依存性** | EMA.js固有の欠陥は何か？他の言語では発生しない欠陥は？ |

**3. Criterion 2.4（振る舞い変化）の観点からの考察候補**

| 観点 | 設計による違い | 欠陥への影響 |
|------|---------------|-------------|
| デフォルト振る舞いの必要性 | 必要 vs 不要 | 未定義振る舞いの発生可能性 |
| 複数BContextへのバインド | 可能 vs 不可 | 変更の波及範囲 |
| スコープ | インスタンス vs グローバル vs スレッド | 意図しない影響範囲 |
| 実行順序の決定方法 | ランダム vs 明示的 vs 活性化順 vs 優先度 | **予測可能性** |

**4. 次のステップ**

- 各言語（ServalCJ, Subjective-C, COBPjs）の具体的な設計を Section 4, 5, 6 で確認
- EMA.js の設計がどの分類に当たるか特定
- その上で、私たちのアサーションがカバーしている欠陥を再評価

---

## 欠陥パターンの分類

TODO: 論文サーベイを続けて整理

### 分類軸の候補

1. **構成要素** × **コンテキスト分類** のマトリクス
2. 例: 「Activation × System-dependent = 予期しない内部状態遷移」

---

## 本研究のカバレッジ

TODO: 欠陥パターンが整理できたら、実装済みアサーションとマッピング

### 実装済みアサーション（参考）

| アサーション | 説明 |
|------------|------|
| `toBeActive()` | 層が活性化しているか判定 |
| `toBePartialMethodOf(Layer)` | メソッドがどの層の部分メソッドか判定 |
| `toBeOriginalMethod()` | メソッドが元のメソッドか判定 |
| `assertLayerStateUnchanged()` | 実行中に層の状態が変わらないことを検証 |
| `assertLayerStateTransition()` | 層状態の遷移を検証 |
| `assertNoConflictingMethodCalled()` | 競合メソッド呼び出しを検出 |
